\documentclass[]{report}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}


\usepackage{hyperref}


\newtheorem{axiom}{Axiom}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{red}{Dmitry notes}}{#1}}}


% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}



\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\btc}{\includegraphics[height=8pt]{assets/btc.jpg}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\newcommand{\dlog}{dlog(h)}
\newcommand{\pedersen}{pcom(h, c)}
\newcommand{\height}{\mathcal{H}}
\newcommand{\ergo}{$\Sigma$RGO}

\newcommand{\ecash}{$\Sigma$-Cash}

\newcommand{\edata}{$\Sigma$-Data}

\newcommand{\state}{\textit{State}}
\newcommand{\roller}{\textbf{Rollerchain}}
\newcommand{\aspen}{\textbf{Aspen}}
\newcommand{\bitcoinng}{\textbf{Bitcoin-ng}}
\newcommand{\sse}{\textbf{Space-Scarce Economy}}
\newcommand{\popow}{\textbf{PoPoW}}
\newcommand{\ads}{\textbf{ADS}}
\newcommand{\ssal}{\textbf{$\Sigma$SAL}}

% as we do not know which term to use for a state element, we use a command for this
\newcommand{\coin}{coin}
\newcommand{\Coin}{Coin}

\newcommand{\extract}[1]{$extract({#1})$}

\usepackage[utf8]{inputenc}

\usepackage{minted}
\usemintedstyle{manni}
\usepackage{microtype}
 

\begin{document}

\title{The \ergo{} Yellowpaper}
\author{Alexander Chepurnoy \and Nazeem Faour \and Dmitry Meshkov}
\maketitle

\newpage
\tableofcontents

\section{Introduction}
\subsection{Multiple Modes}
Ergo (since the very first testing network Testnet0) is supporting multiple security models. In addition to full node
mode, which is similar to Bitcoin fullnode, Ergo reference implementation supports Light-SPV, Light-Fullnode and Pruned-Fullnode modes.

\subsection{Full-Node Mode}
Like in Bitcoin, a full node is storing all the full blocks since genesis block. Full node checks proofs of work, linking structure correctness (parent block id, interlink elements), and all the transactions in all the blocks. A fullnode is storing all the full blocks forever. It is also holding full UTXO set to be able to validate an arbitrary transaction.
The only optimization a fullnode is doing is that is is skipping downloading and checking AD-transformation block part (see below in the "Light-Fullnode" section).
For the full node regime, modifiers precessing workflow is as follows:
\begin{enumerate}
   \item Send ErgoSyncInfo message to connected peers.
   \item Get response with INV message, containing ids of blocks, better than our best block.
   \item Request headers for all ids from 2.
   \item On receiving header:
   \begin{minted}{java}
if(history.apply(header).isSuccess) {
    if(!isInitialBootstrapping) Broadcast INV for this header   
    Request transaction ids from this block
 } else {
    blacklist peer
 }
\end{minted} 
\vspace{1em}

 % Mempool.apply(transactionIdsForHeader)
   \item On receiving transaction ids from header:
   \begin{minted}{java}
  transactionIdsForHeader.filter(txId => !MemPool.contains(txId)).foreach { txId => 
    request transaction with txId
  }
   \end{minted}
   \item On receiving a transaction:
   \begin{minted}{java}
   if(Mempool.apply(transaction).isSuccess) {
    if(!isInitialBootstrapping) Broadcast INV for this transaction
    Mempool.getHeadersWithAllTransactions { BlockTransactions =>
       GOTO 7
    }
 }
   \end{minted}
   \item Now we have BlockTransactions: all transactions corresponding to some Header
   \begin{minted}{java}
    if(History.apply(BlockTransactions) == Success(ProgressInfo)) {
      if(!isInitialBootstrapping) Broadcast INV for BlockTransactions
     /*We should notify our neighbours, that now we have all the transactions
     State apply modifiers (may be empty for block in a fork chain)
     and generate ADProofs for them.
     TODO requires different interface from scorex-core,
     because it should return ADProofs
     TODO when mininal state apply Progress info,
     it may also create UTXOSnapshot
     (e.g. every 30000 blocks like in Ethereum).
     This UTXOSnapshot should be required for mining by Rollerchain*/
     if(State().apply(ProgressInfo) == Success((newState, ADProofs))) {
       if("mode"="full" || "mode"=="pruned-full") ADProofs.foreach ( ADProof => History.apply(ADProof))
       if("mode"=="pruned-full" || "mode"=="light-full") drop BlockTransactions and ADProofs older than BlocksToKeep
     } else {
       //Drop Header from history, because it's transaction sequence is not valid
       History.drop(BlockTransactions.headerId)
     }
  } else {
    blacklist peer who sent header
  }
   \end{minted}
\end{enumerate}

\subsection{Pruned Full-Node Mode}
This mode is similar to fast-sync in Geth or Grothendieck, warp-mode in Parity (all the three are Ethereum protocol clients), but makes more aggressive optimizations. In particular, a pruned-fullnode is not down- loading and storing full blocks not residing in a target blockchain suffix, and also removing full blocks going out of the suffix.
In detail, a pruned client is downloading all the headers, then, by using them, it checks proofs-of-work and linking structure(or parent id only?). Then it downloads a UTXO snapshot for some height from its peers. Finally, full blocks after the snapshot are to be downloaded and applied to get a current UTXO set.
A pruned fullnode is also skipping AD-transformation block part, like a fullnode. Additional setting: "suffix" - how much full blocks to store(w. some minimum set?).
Its regular modifiers processing is the same as for fullnode regime, while its bootstrap process is different:
\begin{enumerate}
\item Send ErgoSyncInfo message to connected peers.
\item Get response with INV message, containing ids of blocks, better than our best block.
\item Request headers for all ids from 2.
\item On receiving header:
\begin{minted}{java}
if(History.apply(header).isSuccess) {
    if(!(localScore == networkScore)) GOTO 1
    else GOTO 5
 } else {
    blacklist peer
 }
\end{minted}

\item Request historical UTXOManifest for at least BlocksToKeep back.

\item On receiving UTXOSnapshotManifest:

\begin{minted}{java}
UTXOSnapshotManifest.chunks.foreach { chunk => 
    request chunk from sender() //Or from random fullnode
  }
\end{minted}
\item On receiving UTXOSnapshotChunk:
\begin{minted}{java}
State.applyChunk(UTXOSnapshotChunk) match {
     case Success(Some(newMinimalState)) => GOTO 8
     case Success(None) => stay at 7 
     /*we need more chunks to construct state. 
     TODO periodicaly request missed chunks*/
     case Failure(e) => ???
     //UTXOSnapshotChunk or constcucted state roothash is invalid  
  }
\end{minted}

\item Request BlockTransactions starting from State we have
\begin{minted}{java}
History.headersStartingFromId(State.headerId).foreach { header => 
    send message(GetBlockTransactionsForHeader(header)) to Random fullnode
  }
\end{minted}
\item On receiving BlockTransactions: same as in Fullnode.7 .
\item Operate as Fullnode.


\end{enumerate}

\subsection{Light Full-Node Mode}
This mode is based on an idea to use a 2-party authenticated dynamic dictionary built on top of UTXO set. A light-fullnode holds only a root digest of a dictionary. It check all the full blocks, or some suffix of the full blockchain, depending on setting, thus starting from a trusted pre-genesis digest or some digest in the blockchain. A light-fullnode is using AD-transformations (authenticated dictionary transformations) block section containing batch-proof for UTXO transformations to get a new digest from an old one. It also checks all the transactions, but doesn’t store anything but a single digest for that. Details can be found in the paper https://eprint.iacr.org/2016/994. \par
Additional settings : "depth" - from which block in the past to check transactions (if 0, then go from genesis). \par
"additional-checks" - light-fullnode trusts previous digest and checks current digest validity by using the previous one as well as AD-transformations. \par
"additional-depth" - depth to start additional checks from.
\begin{enumerate}
\item Send ErgoSyncInfo message to connected peers.
\item Get response with INV message, containing ids of blocks, better than our best block.
\item Request headers for all ids from 2.
\item On receiving header:
\begin{minted}{java}
if(History.apply(header).isSuccess) {
    if(!(localScore == networkScore)) GOTO 1
    else GOTO 5
 } else {
    blacklist peer
 }
\end{minted}
\item Request BlockTransactions and ADProofs starting from BlocksToKeep back in History (just 1 last header after node botstrapping):
\begin{minted}{java}
History.lastBestHeaders(BlocksToKeep).foreach { header => 
    send message(GetBlockTransactionsForHeader(header)) to Random fullnode
    send message(GetAdProofsHeader(header)) to Random fullnode
  }
\end{minted}
\item On receiving modifier BlockTransactions or ADProofs:
\begin{minted}{java}
if(History.apply(modifier) == Success(ProgressInfo)) {
  /* TODO if history now contains both ADProofs and BlockTransactions,
  it should return ProgressInfo with both of them, otherwise
  it should return empty ProgressInfo */
if(State().apply(ProgressInfo) == Success((newState, ADProofs)))
{
if("mode"=="pruned-full") drop BlockTransactions and ADProofs older than BlocksToKeep
} 
else {
         /*Drop Header from history, because it's transaction sequence is not valid*/
         History.drop(BlockTransactions.headerId)
     }
  }
\end{minted}
\end{enumerate}

\subsection{Light-SPV Mode}
This mode is not about checking any full blocks. Like in Bitcoin, an SPV node is downloading block headers only, and so checks only proofs of work and links. Unlike Bitcoin’s SPV, the Light-SPV is downloading and checking not all the headers but a sublinear(in blockchain length) number of them(in benchmarks, this is about just tens of kilobytes instead of tens or hundreds of megabytes for Bitcoin/Ethereum).
Light-SPV mode is intended to be useful for mobile phones and low-end hardware.
\subsubsection{Bootstrap}
\begin{enumerate}
\item Send GetPoPoWProof for all connections.
\item On receive PoPoWProof apply it to History (History should be able to determine, whether this PoPoWProof is better, than it's current best header chain).
\item GOTO regular regime.
\end{enumerate}
\subsubsection{Regular}
\begin{enumerate}
\item Send ErgoSyncInfo message to connected peers
\item Get response with INV message, containing ids of blocks, better than our best block.
\item Request headers for all ids from 2.
\item On receiving header:
\begin{minted}{java}
 if(History.apply(header).isSuccess) {
    State.apply(header) // just change state roothash
    if(!isInitialBootstrapping) Broadcast INV for this header
 } else {
    blacklist peer
 }
\end{minted}
\end{enumerate}
\subsection{Mode-Related Settings}
Ergo has the following settings determines a mode:
\begin{itemize}
\item ADState: Boolean - keeps state roothash only.
\item VerifyTransactions: Boolean - download block transactions and verify them (requires BlocksToKeep == 0 if disabled).
\item PoPoWBootstrap: Boolean - download PoPoW proof only
\item BlocksToKeep: Int - number of last blocks to keep with transactions, for all other blocks it keep header
only. Keep all blocks from genesis if negative
\item MinimalSuffix: Int - minimal suffix size for PoPoW proof (may be pre-defined constant).
\end{itemize}
\par 
‘if(VerifyTransactions == false) require(BlocksToKeep == 0)‘ Mode from **"multimode.md"** can be determined as follows:

\section{Ergo Block Structure}
\subsection{ErgoMinimalHeader is a minimal data amount, required to calculate blockId:}
payloadRootHash: Array[Byte] - root hash (or simple hash of all payload data) of block payload.
nonce: Int - field to iterate and generate valid PoW.
\subsection{ErgoHeader is a header to keep in History and transfer:}
\vspace{1em}
\begin{tabular}{ |p{2.5cm}||p{0.5cm}|p{7.5cm}|  }
 \hline
 \hline
 Field & Size & Description  \\
 \hline
 version  &  1 &  block version, to be increased on every soft- and hardfork  \\
 \hline
 parentId &  32 &  id of parent block  \\
 \hline
 interlinksRoot &  32 &  root hash of interlinks structure  \\
 \hline
 ADProofsRoot &  32 &  hash of ADProofs for transactions in a block \\
 \hline
 stateRoot &  32 &  root hash (for an AVL+ tree) of a state after block application  \\
 \hline
 transactionsRoot  &  32 &  root hash (for a Merkle tree) of transactions in a block  \\
 \hline
 timestamp &  8 &  block timestamp(in milliseconds since beginning of Unix Epoch)  \\
 \hline
 nonce &  8 &  Proof-of-Work nonce  \\
 \hline
\end{tabular}

\vspace{1em}
Some of this fields may be calculated by node by itself: 

  
   \begin{itemize}
     \item parentId: if(status==bootstrap AND PoPoWBootstrap == false).
     \item interlinksRoot: if(PoPoWBootstrap == false).
     \item ADProofsRoot: if(status==regular AND ADState==false AND BlocksToKeep>0).
     \item stateRoot: if(status==regular AND ADState==false AND BlocksToKeep>0).
     \end{itemize}
     

\section{Ergo Modifiers Processing}
This section describes processing algorithm for Ergo modifiers in all security modes. Unlike most of blockchain systems, Ergo have the following types of **modifiers**: In-memory:
\begin{enumerate}
\item In-memory:
\begin{itemize}
\item Transaction - in-memory modifier.
\item TransactionIdsForHeader - ids of transactions in concrete block.
\item UTXOSnapshotManifest - ids of UTXO chunks and
\end{itemize}
\item Persistent:
\begin{itemize}
\item BlockTransactions - Sequence of transactions, corresponding to 1 block.
\item ADProofs - proof of transaction correctness relative to corresponding UTXO.
\item Header, that contains data required to verify PoW, link to previous block, state root hash and root hash to it's payload (BlockTransactions, ADProofs, Interlinks ...).
\item UTXOSnapshotChunk - part of UTXO.
\item PoPoWProof
\end{itemize}
Ergo will have the following parameters, that will determine concrete security regime:
\begin{itemize}
\item ADState: Boolean - keep state roothash only.
\item VerifyTransactions: Boolean - download block transactions and verify them (requires BlocksToKeep == 0 if disabled).
\item PoPoWBootstrap: Boolean - download PoPoW proof only.
\item BlocksToKeep: Int - number of last blocks to keep with transactions, for all other blocks it keep header only. Keep all blocks from genesis if negative.
\item MinimalSuffix: Int - minimal suffix size for PoPoW proof (may be pre-defined constant).
\begin{minted}{java}
if(VerifyTransactions == false) require(BlocksToKeep == 0)
\end{minted}
\end{itemize}
Mode from "multimode.md" can be determined as follows:
\begin{minted}{java}
mode = if(ADState == false && VerifyTransactions == true
&& PoPoWBootstrap == false && BlocksToKeep < 0) "full"
else if(ADState == false && VerifyTransactions == true
&& PoPoWBootstrap == false && BlocksToKeep >= 0) "pruned-full"
else if(ADState == true && VerifyTransactions == true
&& PoPoWBootstrap == false) "light-full"
else if(ADState == true && VerifyTransactions == false
&& PoPoWBootstrap == true && BlocksToKeep == 0) "light-spv"
else if(ADState == true && VerifyTransactions == true
&& PoPoWBootstrap == true && BlocksToKeep == 0) "light-full-PoPoW"
else //Other combinations are possible
\end{minted}
\end{enumerate}
\subsection{Modifiers processing}
\begin{minted}{java}
def updateHeadersChainToBestInNetwork() = {
  1.2.1. Send ErgoSyncInfo message to connected peers
  1.2.2. Get response with INV message,
  containing ids of blocks, better than our best block
  1.2.3. Request headers for all ids from 1.2.2.
  1.2.4. On receiving header
   if(History.apply(header).isSuccess) {
      if(!(localScore == networkScore)) GOTO 1.2.1
   } else {
      blacklist peer
      GOTO 1.2.1
   }
}
\end{minted}

\subsection{bootstrap}
\subsubsection{Download headers:}
\begin{minted}{java}
if(PoPoW) {
 1.1.1. Send GetPoPoWProof(suffix = Max(MinimalSuffix ,BlocksToKeep)) for all connections
 1.1.2. On receive PoPoWProof apply it to History
  /* 
  History should be able to determine, 
  whether this PoPoWProof is better, than it's current best header chain */
} else {
  updateHeadersChainToBestInNetwork()
}
\end{minted}
\subsubsection{Download initial State to start process transactions:}
\begin{minted}{java}
if(ADState == true) {
  Initialize state with state roothash from block header BlocksToKeep ago
} else if(BlocksToKeep < 0 || BlocksToKeep > History.headersHeight) {
  Initialize state with genesis State
} else {
/*
We need to download full state BlocksToKeep back in history
TODO what if we can download state only "BlocksToKeep - N" 
or "BlocksToKeep + N" blocks back? 
*/
  2.1. Request historical UTXOSnapshotManifest for at least BlocksToKeep back
  2.2. On receiving UTXOSnapshotManifest: 
    UTXOSnapshotManifest.chunks.foreach ( chunk => request chunk from sender()
/*Or from random fullnode*/
  2.3. On receiving UTXOSnapshotChunk
  State.applyChunk(UTXOSnapshotChunk) match {
     case Success(Some(newMinimalState)) => GOTO 3
     case Success(None) => stay at 2.3
     /*we need more chunks to construct state. TODO periodicaly request missed chunks*/
     case Failure(e) => ??? 
     /*UTXOSnapshotChunk or constcucted state roothash is invalid*/  
  }
}
\end{minted}
\subsubsection{Update State to best headers height:}
\begin{minted}{java}
 if(State.bestHeader == History.bestHeader) {
    //Do nothing, State is already updated
  } else if(VerifyTransactions == false) {
/*Just update State rootshash to best header in history*/
    State.setBestHeader(History.bestHeader)
  } else {
/*we have headers chain better then full block */        
    3.1. 
      assert(history contains header chain from State.bestHeader to History.bestHeaders)
      History.continuation(from = State.bestHeader, size = ???).get.foreach { header => 
        sendToRandomFullNode(GetBlockTransactionsForHeader(header))
        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))
      }
    3.2. On receiving modifiers ADProofs or BlockTransactions
      /*TODO History should return non-empty ProgressInfo
      only if it contains both ADProofs and BlockTransactions,
      or it contains BlockTransactions and ADState==false*/
      if(History.apply(modifier) == Success(ProgressInfo)) {
        if(State().apply(ProgressInfo) == Success((newState, ADProofs))) {
          if(ADState==false) ADProofs.foreach ( ADProof => History.apply(ADProof))
          if(BlocksToKeep>=0) 
          /*remove BlockTransactions and ADProofs older than BlocksToKeep from history*/
        } else {
      /*Drop Header from history, 
      because it's transaction sequence is not valid*/
          History.drop(modifier.headerId)
        }
      } else {
        blacklistPeer
      }
      GOTO 3
    }
\end{minted}
\subsubsection{GOTO regular mode.}
\begin{minted}{java}

\end{minted}
\subsection{Regular}
Two infinite loops in different threads with the following functions inside:
\begin{enumerate}
\item UpdateHeadersChainToBestInNetwork()
\item Download and update full blocks when needed
\end{enumerate}
\begin{minted}{java}
 if(State.bestHeader == History.bestHeader) {
    //Do nothing, State is already updated
  } else if(VerifyTransactions == false) {
    //Just update State rootshash to best header in history
    State.setBestHeader(History.bestHeader)
  } else {
    //we have headers chain better then full block         
    3.1. Request transaction ids from all headers without transactions
      assert(history contains header chain from State.bestHeader to History.bestHeaders)
      History.continuation(from = State.bestHeader, size = ???).get.foreach { header => 
        sendToRandomFullNode(GetTransactionIdsForHeader(header))
        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))
      }
    3.2. On receiving TransactionIdsForHeader:
      Mempool.apply(TransactionIdsForHeader)
      TransactionIdsForHeader.filter(txId => !MemPool.contains(txId)).foreach { txId => 
        request transaction with txId
      }
    3.3. On receiving a transaction:
      if(Mempool.apply(transaction).isSuccess) {
         Broadcast INV for this transaction
         Mempool.getHeadersWithAllTransactions { BlockTransactions =>
            GOTO 3.4 //now we have BlockTransactions
         }
      }
    3.4. (same as 3.2. from bootstrap)
  }
\end{minted}



\section{Components}
\subsection{History}
\subsection{State}
\subsection{Memory Pool}

\section{Transactional Language}

\section{Protocol Updates}

\section{Peer-to-Peer Network}


\section{Emission Rules}

\knote{are these rules for money chain only?}

First, we are describing some preliminaries before providing rules for coins emission. Target mean delay between blocks
is $\Delta = 2$ minutes. We plan to issue all the tokens in about eight years, thus the number of blocks minting
coins is $E_{total} = 365 \cdot 24 \cdot \frac{60}{\Delta} = 262800$.


\section{Transactions}


A transaction is destroying at least one \coin{}~(potentially many {\coin{}}s, up to $2^{16} - 1$ if block size
limit allows that), and also creating at least one \coin{}. We use the term "destroying", as everything contained
in a \coin{} is disappearing
from the state during transaction application: monetary value, guard script, contents of all the registers,
all the bytes and also an identifier of the \coin{}.

\subsection{\Coin{} Format}
\label{coin-format}

A \coin{} is made of registers~(and nothing but registers), we allow every \coin{} in the system to have up to 8 registers in the \ecash{} chain,
and up to 64 registers in the \edata{} chain. We denote the registers as $R_0,R_1,\ldots,R_{63}$.
From these registers, some are filled with mandatory values: $R_0$ contains monetary value of a \coin{}, $R_1$ contains
serialized guard script, $R_2$ contains unique identifier of transaction which created the coin and also an index of
the coin in the transaction.

Registers are typed: every register contains a value of some type. Types are defined in \knote{ref}. The value should
be evaluated~(i.e. be a constant value).

We introduce \extract{} function, which is reading contents of a register, for example, \extract{c, R_0} extracts monetary value
from the \coin{} $c$.


\subsection{\Coin{} template}
\label{coin-template}

Here we describe difference between a \coin{} and a \coin{} template. A \coin{} has a unique identifier to be defined
deterministically from its contents. Thus we need to have different identifiers for \coin{}s of the same meaning, even
if they are created by the same transaction. We also require a \coin{} to have an identifier which is derived solely
from \coin{} contents, thus we can not use {\em (transaction\_id, output\_id)} pair as Bitcoin Core implementation is
doing.

To solve the issue we split concepts of a \coin{} and a \coin{} template. A \coin{} template is defining semantics of
the corresponding \coin{} i.e. has the same values for all the registers except of the register $R_2$ which is set to
$null$.


\subsection{Transaction Format}
\label{tx-format}

A transaction simply refers to a set of \coin{}s, by providing their identifiers and also spending proofs for
them; the transaction also providing set of new \coin{} templates. A \coin{} template becomes a \coin{} in result of
transaction processing~(however, once transaction is formed, its identifier is known, and so identifier of the future
coin is also known before the application).

We now introduce two functions to extract a \coin{} or a \coin{} template which a transaction is trying to spend.
 In details, function $in(index)$ returns a \coin{} which transaction is trying to spend, by its index, and $out(index)$
 returns a \coin{} template . For example, $in(tx, 0)$ returns the very first \coin{} the transaction $tx$ is trying to spend.

We require for every transaction $tx$, which is trying to spend $c_i$ {\coin}s and create $c_o$ coins,
to preserve overall monetary value:

$ \sum_{i=0}^{c_i - 1}$ \extract{in(tx,i), R_0}$ = \sum_{j=0}^{c_o - 1}$ \extract{out(tx,j), R_0}

\subsection{Transaction Merkle Tree}
\label{tx-tree}

Like a miner in the Bitcoin protocol is building a Merkle tree of block transactions, as well as a Merkle tree of
transaction witnesses~(after the Segwit upgrade), in Ergo, a miner should build a Merkle tree~(and include a correct
 root hash of the tree into a block header), which is in case of Ergo combines both transactions and their respective
 spending proofs.

This tree is to be constructed as follows. A data block under a leaf of the tree could be empty or 64 bytes in length.
Data of 64 bytes contains identifier of the transaction~(256-bits digest of transaction bytes without spending proofs)
and 256 bits of a digest of all the spending proofs for the transaction combined. Data for $i-th$ transaction
in the block~(starting from 0) is authenticated by the $i-th$ leaf.
A leaf is $hash(0 || pos || data)$, if the $data$ is not empty
~(we do add prefix for domain separation), or $null$ otherwise. Here, $pos$ is a position of the transaction in the block.
 For internal nodes, a node is $hash(1 || left\_child || right\_child)$, if either left child or right child of the
 node is not $null$, $null$ othewise. If root hash is $null$, we are writing all zeros~(of hash function output length)
 instead of it.


\subsection{Transaction Identifier and Its Malleability}
\label{tx-identifier}

A transaction has a unique identifier to be defined deterministically from its contents.

There are different ways to produce semantically the same transaction with different identifiers. We are interesting
to prevent {\em unauthorized malleability}. We define unauthorized malleability as a way to change transaction
identifier without re-signing the transaction. One particular way to malleate a transaction is to use signature
malleability, which is common for most popular digital signature schemes.

To prevent unauthorized transaction malleability, we do not put spending proofs under hash function when we calculate a
transaction identifier.

In details, we are constructing bytes to get the transaction identifier~(and in the follow-up section, also a signature)
as follows. We concatenate the following fields:

\begin{itemize}
    \item{\em number of inputs.} Unsigned 2-bytes integer giving a number of \coin{}s the transaction is spending. Thus
    the transaction can not spend more than 65536 \coin{}s.
    \item{\em input identifiers.} Given the number $c_{ins}$ of \coin{}s to spend from the previous field, we form
    $32 * c_{ins}$ bytes, where $i$-th chunk of 32 bytes represents an identifier of $i$-th \coin{} to spend~(see Section
    \ref{coin-format} for details).
    \item{\em number of outputs.} Unsigned 2-bytes integer of \coin{}s the transaction is creating~(again, the
    transaction can not create more than 65,536 \coin{}s).
    \item{\em transaction outputs.}
\end{itemize}

\subsection{Signing Transactions}


\subsection{Unified Transactions}


\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}
\addcontentsline{toc}{section}{References}

\end{document}
