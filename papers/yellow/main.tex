\documentclass[]{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}


\usepackage{hyperref}


\newtheorem{axiom}{Axiom}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{red}{Dmitry notes}}{#1}}}


% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}



\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\btc}{\includegraphics[height=8pt]{assets/btc.jpg}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\newcommand{\dlog}{dlog(h)}
\newcommand{\pedersen}{pcom(h, c)}
\newcommand{\height}{\mathcal{H}}
\newcommand{\ergo}{Ergo}

\newcommand{\ecash}{$\Sigma$-Cash}

\newcommand{\edata}{$\Sigma$-Data}

\newcommand{\state}{\textit{State}}
\newcommand{\roller}{\textbf{Rollerchain}}
\newcommand{\popow}{\textbf{PoPoW}}
\newcommand{\ads}{\textbf{ADS}}

% as we do not know which term to use for a state element, we use a command for this
\newcommand{\coin}{coin}
\newcommand{\Coin}{Coin}

\newcommand{\sigm}{sigma}

\newcommand{\extract}[1]{$extract({#1})$}

\usepackage[utf8]{inputenc}

\usepackage{minted}
\usemintedstyle{manni}
\usepackage{microtype}
 

\begin{document}

\title{The \ergo{} Yellowpaper}
\author{Alexander Chepurnoy \and Nazeem Faour \and Dmitry Meshkov}
\maketitle

\newpage
\tableofcontents

\section{Introduction}


\section{Notation and Preliminaries}

\subsection{A Note on Notation}

\knote{say about coin/box/output}


\subsection{Cryptographic Primitives}

We use Blake2b hash function with 256 bits output.

\knote{describe a curve used}


\section{Modes of Operation}
Ergo (since the very first testing network Testnet0) is supporting multiple security models. In addition to full node
mode, which is similar to Bitcoin fullnode, Ergo reference implementation supports Light-SPV, Light-Fullnode and Pruned-Fullnode modes.

\subsection{Full-Node Mode}
Like in Bitcoin, a full node is storing all the full blocks since genesis block. Full node checks proofs of work, linking structure correctness (parent block id, interlink elements), and all the transactions in all the blocks. A fullnode is storing all the full blocks forever. It is also holding full UTXO set to be able to validate an arbitrary transaction.
The only optimization a fullnode is doing is that is skipping downloading and checking AD-transformation block part (see below in the "Light-Fullnode" section).
For the full node regime, modifiers processing workflow is as follows:
\begin{enumerate}
   \item Send ErgoSyncInfo message to connected peers.
   \item Get response with INV message, containing ids of blocks, better than our best block.
   \item Request headers for all ids from 2.
   \item On receiving header:
   \begin{minted}{java}
if(history.apply(header).isSuccess) {
    if(!isInitialBootstrapping) Broadcast INV for this header   
    Request transaction ids from this block
 } else {
    blacklist peer
 }
\end{minted} 
\vspace{1em}

 % Mempool.apply(transactionIdsForHeader)
   \item On receiving transaction ids from header:
   \begin{minted}{java}
  transactionIdsForHeader.filter(txId => !MemPool.contains(txId)).foreach { txId => 
    request transaction with txId
  }
   \end{minted}
   \item On receiving a transaction:
   \begin{minted}{java}
   if(Mempool.apply(transaction).isSuccess) {
    if(!isInitialBootstrapping) Broadcast INV for this transaction
    Mempool.getHeadersWithAllTransactions { BlockTransactions =>
       GOTO 7
    }
 }
   \end{minted}
   \item Now we have BlockTransactions: all transactions corresponding to some Header
   \begin{minted}{java}
    if(History.apply(BlockTransactions) == Success(ProgressInfo)) {
      if(!isInitialBootstrapping) Broadcast INV for BlockTransactions
     /*We should notify our neighbours, that now we have all the transactions
     State apply modifiers (may be empty for block in a fork chain)
     and generate ADProofs for them.
     TODO requires different interface from scorex-core,
     because it should return ADProofs
     TODO when minimal state apply Progress info,
     it may also create UTXOSnapshot
     (e.g. every 30000 blocks like in Ethereum).
     This UTXOSnapshot should be required for mining by Rollerchain*/
     if(State().apply(ProgressInfo) == Success((newState, ADProofs))) {
       if("mode"="full" || "mode"=="pruned-full") ADProofs.foreach ( ADProof => History.apply(ADProof))
       if("mode"=="pruned-full" || "mode"=="light-full") drop BlockTransactions and ADProofs older than BlocksToKeep
     } else {
       //Drop Header from history, because it's transaction sequence is not valid
       History.drop(BlockTransactions.headerId)
     }
  } else {
    blacklist peer who sent header
  }
   \end{minted}
\end{enumerate}

\subsection{Pruned Full-Node Mode}
This mode is similar to fast-sync in Geth or Grothendieck, warp-mode in Parity (all the three are Ethereum protocol clients), but makes more aggressive optimizations. In particular, a pruned-fullnode is not down- loading and storing full blocks not residing in a target blockchain suffix, and also removing full blocks going out of the suffix.
In detail, a pruned client is downloading all the headers, then, by using them, it checks proofs-of-work and linking structure(or parent id only?). Then it downloads a UTXO snapshot for some height from its peers. Finally, full blocks after the snapshot are to be downloaded and applied to get a current UTXO set.
A pruned fullnode is also skipping AD-transformation block part, like a fullnode. Additional setting: "suffix" - how much full blocks to store(w. some minimum set?).
Its regular modifiers processing is the same as for fullnode regime, while its bootstrap process is different:
\begin{enumerate}
\item Send ErgoSyncInfo message to connected peers.
\item Get response with INV message, containing ids of blocks, better than our best block.
\item Request headers for all ids from 2.
\item On receiving header:
\begin{minted}{java}
if(History.apply(header).isSuccess) {
    if(!(localScore == networkScore)) GOTO 1
    else GOTO 5
 } else {
    blacklist peer
 }
\end{minted}

\item Request historical UTXOManifest for at least BlocksToKeep back.

\item On receiving UTXOSnapshotManifest:

\begin{minted}{java}
UTXOSnapshotManifest.chunks.foreach { chunk => 
    request chunk from sender() //Or from random fullnode
  }
\end{minted}
\item On receiving UTXOSnapshotChunk:
\begin{minted}{java}
State.applyChunk(UTXOSnapshotChunk) match {
     case Success(Some(newMinimalState)) => GOTO 8
     case Success(None) => stay at 7 
     /*we need more chunks to construct state. 
     TODO periodicaly request missed chunks*/
     case Failure(e) => ???
     //UTXOSnapshotChunk or constcucted state roothash is invalid  
  }
\end{minted}

\item Request BlockTransactions starting from State we have
\begin{minted}{java}
History.headersStartingFromId(State.headerId).foreach { header => 
    send message(GetBlockTransactionsForHeader(header)) to Random fullnode
  }
\end{minted}
\item On receiving BlockTransactions: same as in Fullnode.7 .
\item Operate as Fullnode.


\end{enumerate}

\subsection{Light Full-Node Mode}
This mode is based on an idea to use a 2-party authenticated dynamic dictionary built on top of UTXO set. A light-fullnode holds only a root digest of a dictionary. It checks all the full blocks, or some suffix of the full blockchain, depending on setting, thus starting from a trusted pre-genesis digest or some digest in the blockchain. A light-fullnode is using AD-transformations (authenticated dictionary transformations) block section containing batch-proof for UTXO transformations to get a new digest from an old one. It also checks all the transactions, but doesn’t store anything but a single digest for that. Details can be found in the paper https://eprint.iacr.org/2016/994. \par
Additional settings : "depth" - from which block in the past to check transactions (if 0, then go from genesis). \par
"additional-checks" - light-fullnode trusts previous digest and checks current digest validity by using the previous one as well as AD-transformations. \par
"additional-depth" - depth to start additional checks from.
\begin{enumerate}
\item Send ErgoSyncInfo message to connected peers.
\item Get response with INV message, containing ids of blocks, better than our best block.
\item Request headers for all ids from 2.
\item On receiving header:
\begin{minted}{java}
if(History.apply(header).isSuccess) {
    if(!(localScore == networkScore)) GOTO 1
    else GOTO 5
 } else {
    blacklist peer
 }
\end{minted}
\item Request BlockTransactions and ADProofs starting from BlocksToKeep back in History (just 1 last header after node botstrapping):
\begin{minted}{java}
History.lastBestHeaders(BlocksToKeep).foreach { header => 
    send message(GetBlockTransactionsForHeader(header)) to Random fullnode
    send message(GetAdProofsHeader(header)) to Random fullnode
  }
\end{minted}
\item On receiving modifier BlockTransactions or ADProofs:
\begin{minted}{java}
if(History.apply(modifier) == Success(ProgressInfo)) {
  /* TODO if history now contains both ADProofs and BlockTransactions,
  it should return ProgressInfo with both of them, otherwise
  it should return empty ProgressInfo */
if(State().apply(ProgressInfo) == Success((newState, ADProofs)))
{
if("mode"=="pruned-full") drop BlockTransactions and ADProofs older than BlocksToKeep
} 
else {
         /*Drop Header from history, because it's transaction sequence is not valid*/
         History.drop(BlockTransactions.headerId)
     }
  }
\end{minted}
\end{enumerate}

\subsection{Light-SPV Mode}
This mode is not about checking any full blocks. Like in Bitcoin, an SPV node is downloading block headers only, and so checks only proofs of work and links. Unlike Bitcoin’s SPV, the Light-SPV is downloading and checking not all the headers but a sublinear(in blockchain length) number of them(in benchmarks, this is about just tens of kilobytes instead of tens or hundreds of megabytes for Bitcoin/Ethereum).
Light-SPV mode is intended to be useful for mobile phones and low-end hardware.
\subsubsection{Bootstrap}
\begin{enumerate}
\item Send GetPoPoWProof for all connections.
\item On receive PoPoWProof apply it to History (History should be able to determine, whether this PoPoWProof is better than it's current best header chain).
\item GOTO regular regime.
\end{enumerate}
\subsubsection{Regular}
\begin{enumerate}
\item Send ErgoSyncInfo message to connected peers
\item Get response with INV message, containing ids of blocks, better than our best block.
\item Request headers for all ids from 2.
\item On receiving header:
\begin{minted}{java}
 if(History.apply(header).isSuccess) {
    State.apply(header) // just change state roothash
    if(!isInitialBootstrapping) Broadcast INV for this header
 } else {
    blacklist peer
 }
\end{minted}
\end{enumerate}
\subsection{Mode-Related Settings}
Ergo has the following settings determines a mode:
\begin{itemize}
\item ADState: Boolean - keeps state roothash only.
\item VerifyTransactions: Boolean - download block transactions and verify them (requires BlocksToKeep == 0 if disabled).
\item PoPoWBootstrap: Boolean - download PoPoW proof only
\item BlocksToKeep: Int - number of last blocks to keep with transactions, for all other blocks it keep header
only. Keep all blocks from genesis if negative
\item MinimalSuffix: Int - minimal suffix size for PoPoW proof (may be pre-defined constant).
\end{itemize}
\par 
‘if(VerifyTransactions == false) require(BlocksToKeep == 0)‘ Mode from **"multimode.md"** can be determined as follows:

\section{Ergo Block Structure}
\subsection{ErgoMinimalHeader is a minimal data amount, required to calculate blockId:}
payloadRootHash: Array[Byte] - root hash (or simple hash of all payload data) of block payload.
nonce: Int - field to iterate and generate valid PoW.
\subsection{ErgoHeader is a header to keep in History and transfer:}
\vspace{1em}
\begin{tabular}{ |p{2.5cm}||p{0.5cm}|p{7.5cm}|  }
 \hline
 \hline
 Field & Size & Description  \\
 \hline
 version  &  1 &  block version, to be increased on every soft- and hardfork  \\
 \hline
 parentId &  32 &  id of parent block  \\
 \hline
 interlinksRoot &  32 &  root hash of interlinks structure  \\
 \hline
 ADProofsRoot &  32 &  hash of ADProofs for transactions in a block \\
 \hline
 stateRoot &  32 &  root hash (for an AVL+ tree) of a state after block application  \\
 \hline
 transactionsRoot  &  32 &  root hash (for a Merkle tree) of transactions in a block  \\
 \hline
 timestamp &  8 &  block timestamp(in milliseconds since beginning of Unix Epoch)  \\
 \hline

 nBits     &  8 &  Difficulty  \\
 \hline

 height    &  4 &  Height of the header  \\
 \hline

 extensionHash &  32 &  Hash of the extension section of the block  \\
 \hline

 equihashSolution     &  ?? &  Proof-of-Work solution   \\
 \hline
\end{tabular}

\vspace{1em}
Some of this fields may be calculated by node by itself: 

  
   \begin{itemize}
     \item parentId: if(status==bootstrap AND PoPoWBootstrap == false).
     \item interlinksRoot: if(PoPoWBootstrap == false).
     \item ADProofsRoot: if(status==regular AND ADState==false AND BlocksToKeep>0).
     \item stateRoot: if(status==regular AND ADState==false AND BlocksToKeep>0).
     \end{itemize}

\knote{height, nBits, extensionHash could be got locally as well, update the list above}

\section{Ergo Modifiers Processing}
This section describes processing algorithm for Ergo modifiers in all security modes. Unlike most of blockchain systems, Ergo have the following types of **modifiers**: In-memory:
\begin{enumerate}
\item In-memory:
\begin{itemize}
\item Transaction - in-memory modifier.
\item TransactionIdsForHeader - ids of transactions in concrete block.
\item UTXOSnapshotManifest - ids of UTXO chunks and
\end{itemize}
\item Persistent:
\begin{itemize}
\item BlockTransactions - Sequence of transactions, corresponding to 1 block.
\item ADProofs - proof of transaction correctness relative to corresponding UTXO.
\item Header, that contains data required to verify PoW, link to previous block, state root hash and root hash to it's payload (BlockTransactions, ADProofs, Interlinks ...).
\item UTXOSnapshotChunk - part of UTXO.
\item PoPoWProof
\end{itemize}
Ergo will have the following parameters, that will determine concrete security regime:
\begin{itemize}
\item ADState: Boolean - keep state roothash only.
\item VerifyTransactions: Boolean - download block transactions and verify them (requires BlocksToKeep == 0 if disabled).
\item PoPoWBootstrap: Boolean - download PoPoW proof only.
\item BlocksToKeep: Int - number of last blocks to keep with transactions, for all other blocks it keep header only. Keep all blocks from genesis if negative.
\item MinimalSuffix: Int - minimal suffix size for PoPoW proof (may be pre-defined constant).
\begin{minted}{java}
if(VerifyTransactions == false) require(BlocksToKeep == 0)
\end{minted}
\end{itemize}
Mode from "multimode.md" can be determined as follows:
\begin{minted}{java}
mode = if(ADState == false && VerifyTransactions == true
&& PoPoWBootstrap == false && BlocksToKeep < 0) "full"
else if(ADState == false && VerifyTransactions == true
&& PoPoWBootstrap == false && BlocksToKeep >= 0) "pruned-full"
else if(ADState == true && VerifyTransactions == true
&& PoPoWBootstrap == false) "light-full"
else if(ADState == true && VerifyTransactions == false
&& PoPoWBootstrap == true && BlocksToKeep == 0) "light-spv"
else if(ADState == true && VerifyTransactions == true
&& PoPoWBootstrap == true && BlocksToKeep == 0) "light-full-PoPoW"
else //Other combinations are possible
\end{minted}
\end{enumerate}
\subsection{Modifiers processing}
\begin{minted}{java}
def updateHeadersChainToBestInNetwork() = {
  1.2.1. Send ErgoSyncInfo message to connected peers
  1.2.2. Get response with INV message,
  containing ids of blocks, better than our best block
  1.2.3. Request headers for all ids from 1.2.2.
  1.2.4. On receiving header
   if(History.apply(header).isSuccess) {
      if(!(localScore == networkScore)) GOTO 1.2.1
   } else {
      blacklist peer
      GOTO 1.2.1
   }
}
\end{minted}

\subsection{bootstrap}
\subsubsection{Download headers:}
\begin{minted}{java}
if(PoPoW) {
 1.1.1. Send GetPoPoWProof(suffix = Max(MinimalSuffix ,BlocksToKeep)) for all connections
 1.1.2. On receive PoPoWProof apply it to History
  /* 
  History should be able to determine, 
  whether this PoPoWProof is better, than it's current best header chain */
} else {
  updateHeadersChainToBestInNetwork()
}
\end{minted}
\subsubsection{Download initial State to start process transactions:}
\begin{minted}{java}
if(ADState == true) {
  Initialize state with state roothash from block header BlocksToKeep ago
} else if(BlocksToKeep < 0 || BlocksToKeep > History.headersHeight) {
  Initialize state with genesis State
} else {
/*
We need to download full state BlocksToKeep back in history
TODO what if we can download state only "BlocksToKeep - N" 
or "BlocksToKeep + N" blocks back? 
*/
  2.1. Request historical UTXOSnapshotManifest for at least BlocksToKeep back
  2.2. On receiving UTXOSnapshotManifest: 
    UTXOSnapshotManifest.chunks.foreach ( chunk => request chunk from sender()
/*Or from random fullnode*/
  2.3. On receiving UTXOSnapshotChunk
  State.applyChunk(UTXOSnapshotChunk) match {
     case Success(Some(newMinimalState)) => GOTO 3
     case Success(None) => stay at 2.3
     /*we need more chunks to construct state. TODO periodicaly request missed chunks*/
     case Failure(e) => ??? 
     /*UTXOSnapshotChunk or constcucted state roothash is invalid*/  
  }
}
\end{minted}
\subsubsection{Update State to best headers height:}
\begin{minted}{java}
 if(State.bestHeader == History.bestHeader) {
    //Do nothing, State is already updated
  } else if(VerifyTransactions == false) {
/*Just update State rootshash to best header in history*/
    State.setBestHeader(History.bestHeader)
  } else {
/*we have headers chain better than full block */
    3.1. 
      assert(history contains header chain from State.bestHeader to History.bestHeaders)
      History.continuation(from = State.bestHeader, size = ???).get.foreach { header => 
        sendToRandomFullNode(GetBlockTransactionsForHeader(header))
        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))
      }
    3.2. On receiving modifiers ADProofs or BlockTransactions
      /*TODO History should return non-empty ProgressInfo
      only if it contains both ADProofs and BlockTransactions,
      or it contains BlockTransactions and ADState==false*/
      if(History.apply(modifier) == Success(ProgressInfo)) {
        if(State().apply(ProgressInfo) == Success((newState, ADProofs))) {
          if(ADState==false) ADProofs.foreach ( ADProof => History.apply(ADProof))
          if(BlocksToKeep>=0) 
          /*remove BlockTransactions and ADProofs older than BlocksToKeep from history*/
        } else {
      /*Drop Header from history, 
      because it's transaction sequence is not valid*/
          History.drop(modifier.headerId)
        }
      } else {
        blacklistPeer
      }
      GOTO 3
    }
\end{minted}
\subsubsection{GOTO regular mode.}
\begin{minted}{java}

\end{minted}
\subsection{Regular}
Two infinite loops in different threads with the following functions inside:
\begin{enumerate}
\item UpdateHeadersChainToBestInNetwork()
\item Download and update full blocks when needed
\end{enumerate}
\begin{minted}{java}
 if(State.bestHeader == History.bestHeader) {
    //Do nothing, State is already updated
  } else if(VerifyTransactions == false) {
    //Just update State rootshash to best header in history
    State.setBestHeader(History.bestHeader)
  } else {
    //we have headers chain better then full block         
    3.1. Request transaction ids from all headers without transactions
      assert(history contains header chain from State.bestHeader to History.bestHeaders)
      History.continuation(from = State.bestHeader, size = ???).get.foreach { header => 
        sendToRandomFullNode(GetTransactionIdsForHeader(header))
        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))
      }
    3.2. On receiving TransactionIdsForHeader:
      Mempool.apply(TransactionIdsForHeader)
      TransactionIdsForHeader.filter(txId => !MemPool.contains(txId)).foreach { txId => 
        request transaction with txId
      }
    3.3. On receiving a transaction:
      if(Mempool.apply(transaction).isSuccess) {
         Broadcast INV for this transaction
         Mempool.getHeadersWithAllTransactions { BlockTransactions =>
            GOTO 3.4 //now we have BlockTransactions
         }
      }
    3.4. (same as 3.2. from bootstrap)
  }
\end{minted}


%
%\section{Components}
%\subsection{History}
%\subsection{State}
%\subsection{Memory Pool}
%
%\section{Transactional Language}
%
%\section{Protocol Updates}
%
%\section{Peer-to-Peer Network}

\include{emission}

\section{Transactions}


A transaction is destroying at least one \coin{}~(potentially many {\coin{}}s, up to $2^{16} - 1$ if block size
limit allows that), and also creating at least one \coin{}. We use the term "destroying", as everything contained
in a \coin{} is disappearing
from the state during transaction application: monetary value, guard script, contents of all the registers,
all the bytes and also an identifier of the \coin{}.

\subsection{\Coin{} Format}
\label{coin-format}

A \coin{} is made of registers~(and nothing but registers), we allow every \coin{} in the system to have up to 8 registers in the \ecash{} chain,
and up to 64 registers in the \edata{} chain. We denote the registers as $R_0,R_1,\ldots,R_{63}$.
From these registers, some are filled with mandatory values: $R_0$ contains monetary value of a \coin{}, $R_1$ contains
serialized guard script, $R_2$ contains unique identifier of transaction which created the coin and also an index of
the coin in the transaction.

Each register is an expression in \sigm language. Thus the registers are typed: every register contains a value of
some type. Types are defined in \knote{ref}. The value should be evaluated~(i.e. be a constant value).

We introduce \extract{} function, which is reading contents of a register, for example, \extract{c, R_0} extracts monetary value
from the \coin{} $c$.

\Coin{} bytes to be used to get the \coin{} identifier, build authenticated tree for the state, and build a transaction,
are to be formed as follows:

\begin{itemize}
    \item{\em monetary value. } We use 64 bits long {\em signed} integer value to store monetary value of the \coin{}
    (we use the signed integer to make processing easier on platforms with no unsigned integers, such as JVM platform).
    This value to be represented as register R0 by wrapping it as a constant of integer type.
    \item{\em bytes of a script. } To see how the script is serialized, see (\knote{link to \sigm language expressions
    serialization}). The script is to be represented as register R1 by wrapping its bytes are constant array of constant
    bytes.
    \item{\em number of additional registers. } Extra registers should come in order (R3, R4, ..., etc), so this number,
    represented as 1-byte value, defines how much non-empty registers are coming after mandatory ones. If the number is
    zero, next field is missed.
    \item{\em additional registers. } Extra registers are serialized without any delimiters. Each register is
    serialized as a \sigm expression.
    \item{\em transaction identifier and index of a transaction output. } Identifier of a transaction which created
    the \coin{}, 32-bytes long, as well as index of the \coin in the transaction outputs, 2-bytes long. These values
    are to be concatenated into a single array of 34 bytes and wrapped into \sigm language constant stored in the
    register $R2$.
\end{itemize}



\subsection{\Coin{} template}
\label{coin-template}

Here we describe difference between a \coin{} and a \coin{} template. A \coin{} has a unique identifier to be defined
deterministically from its contents. Thus we need to have different identifiers for \coin{}s of the same meaning, even
if they are created by the same transaction. We also require a \coin{} to have an identifier which is derived solely
from \coin{} contents, thus we can not use {\em (transaction\_id, output\_id)} pair as Bitcoin Core implementation is
doing.

To solve the issue we split concepts of a \coin{} and a \coin{} template. A \coin{} template is defining semantics of
the corresponding \coin{} i.e. has the same values for all the registers except of the register $R_2$ which is set to
$null$.


\subsection{Transaction Format}
\label{tx-format}

A transaction simply refers to a set of \coin{}s, by providing their identifiers and also spending proofs for
them; the transaction also providing set of new \coin{} templates. A \coin{} template becomes a \coin{} in result of
transaction processing~(however, once transaction is formed, its identifier is known, and so identifier of the future
coin is also known before the application).

We now introduce two functions to extract a \coin{} or a \coin{} template which a transaction is trying to spend.
 In details, function $in(index)$ returns a \coin{} which transaction is trying to spend, by its index, and $out(index)$
 returns a \coin{} template . For example, $in(tx, 0)$ returns the very first \coin{} the transaction $tx$ is trying to spend.

We require for every transaction $tx$, which is trying to spend $c_i$ {\coin}s and create $c_o$ coins,
to preserve overall monetary value:

$ \sum_{i=0}^{c_i - 1}$ \extract{in(tx,i), R_0}$ = \sum_{j=0}^{c_o - 1}$ \extract{out(tx,j), R_0}

\subsection{Transaction Merkle Tree}
\label{tx-tree}

Like a miner in the Bitcoin protocol is building a Merkle tree of block transactions, as well as a Merkle tree of
transaction witnesses~(after the Segwit upgrade), in Ergo, a miner should build a Merkle tree~(and include a correct
 root hash of the tree into a block header), which is in case of Ergo combines both transactions and their respective
 spending proofs.

This tree is to be constructed as follows. A data block under a leaf of the tree could be empty or 64 bytes in length.
Data of 64 bytes contains identifier of the transaction~(256-bits digest of transaction bytes without spending proofs)
and 256 bits of a digest of all the spending proofs for the transaction combined. Data for $i-th$ transaction
in the block~(starting from 0) is authenticated by the $i-th$ leaf.
A leaf is $hash(0 || pos || data)$, if the $data$ is not empty
~(we do add prefix for domain separation), or $null$ otherwise. Here, $pos$ is a position of the transaction in the block.
 For internal nodes, a node is $hash(1 || left\_child || right\_child)$, if either left child or right child of the
 node is not $null$, $null$ othewise. If root hash is $null$, we are writing all zeros~(of hash function output length)
 instead of it.


\subsection{Transaction Identifier and Its Malleability}
\label{tx-identifier}

A transaction has a unique identifier to be defined deterministically from its contents.

There are different ways to produce semantically the same transaction with different identifiers. We are interesting
to prevent {\em unauthorized malleability}. We define unauthorized malleability as a way to change transaction
identifier without re-signing the transaction. One particular way to malleate a transaction is to use signature
malleability, which is common for most popular digital signature schemes.

To prevent unauthorized transaction malleability, we do not put spending proofs under hash function when we calculate a
transaction identifier.

In details, we are constructing bytes to get the transaction identifier~(and in the follow-up section, also a signature)
as follows. We concatenate the following fields:

\begin{itemize}
    \item{\em number of inputs.} Unsigned 2-bytes integer giving a number of \coin{}s the transaction is spending. Thus
    the transaction can not spend more than 65536 \coin{}s.
    \item{\em input identifiers.} Given the number $c_{ins}$ of \coin{}s to spend from the previous field, we form
    $32 * c_{ins}$ bytes, where $i$-th chunk of 32 bytes represents an identifier of $i$-th \coin{} to spend~(see Section
    \ref{coin-format} for details).
    \item{\em number of outputs.} Unsigned 2-bytes integer of \coin{}s the transaction is creating~(again, the
    transaction can not create more than 65,536 \coin{}s).
    \item{\em transaction outputs.} In this section we store serialized \coin{} templates, with no delimiters. A \coin{}
    template is serialized as a \coin{}~(see Section~\ref{coin-format} for details), but without last field~(transaction
    identifier and index of the \coin{} in transaction outputs).
\end{itemize}

Denoting the binary serialization procedure for a transaction $tx$ explained above as $bytes(tx)$, we can derive
transaction identifier $ident(tx)$ from it as:
    $$ident(tx) = hash(bytes(tx))$$

\subsection{Signing A Transaction}

To spend a \coin{} a spending transaction $tx$ has as an input, one needs to use $bytes(tx)$~(note that different inputs
can be signed in parallel, however, the coins being spent are to be specified before signing), as well as current state
of the blockchain, or $context$. To avoid any I/O operations, this context is small. In details, it consists of current
height, last block's state root digest, and the spending transaction along with \coin{}s it spends. The signer also can
extend the context by putting values there.

By having this data, a signer~(or a prover) of an input first reduces the guarding proposition for the input \coin{} by
evaluating, it using the context. Possible results of the reduction are:

\begin{itemize}
    \item{abort} if estimated upper-bound cost of evaluation~(and verification) is too high.
    \item{true} means that the \coin{} is spendable by anyone
    \item{false} means that the \coin{} is not spendable at all~(at least according to the current context)
    \item{expression still containing predicates over the context. } That means context is not enough to evaluate
    some predicates over it. Prover can look into its own not revealed yet secrets in order to extend context. If the
    secrets are found, prover is reducing the expression further and doing the next step, if there is nothing more to
    evaluate. Otherwise the prover aborts.
    \item{expression containing only expressions over secret information provable via $\Sigma$-protocols. } This is the
    most common case, and we are going to explain it in details further.
\end{itemize}

We are having possible complex expression, like $dlog(x_1) \lor (dlog(x2) /\ dlog(x3))$, where $dlog(x)$ means ``prove me
knowledge of a secret $w$, such as for a known group with generator $g$, $g^w = x$, via a non-interactive form of the
Schnorr protocol''. Internally, this exression is represented as a tree~(\knote{draw the tree}). This proof is to be
proven and then serialized into a binary spending proof~(which could be included into a transaction) as follows:

Proving steps for a tree:

\knote{text below is duplicated in Sigma paper, also this is a raw text copypasted from an email}


    1. bottom-up: mark every node real or simulated, according to the following rule. DLogNode -- if you know the secret,
     then real, else simulated. $\lor$: if at least one child real, then real; else simulated. $\land$: if at least one child
     simulated, then simulated; else real. Note that all descendants of a simulated node will be later simulated, even
     if they were marked as real. This is what the next step will do.

     Root should end up real according to this rule -- else you won't be able to carry out the proof in the end.

    2. top-down: mark every child of a simulated node "simulated." If two or more more children of a real $\lor$ are real,
     mark all but one simulated.

    3. top-down: compute a challenge for every simulated child of every $\lor$ and $\land$, according to the following rules.
     If $\lor$, then every simulated child gets a fresh random challenge. If $\land$ (which means $\land$ itself is simulated, and
     all its children are), then every child gets the same challenge as the $\land$.

    4. bottom-up: For every simulated leaf, simulate a response and a commitment (i.e., second and first prover message)
     according to the Schnorr simulator. For every real leaf, compute the commitment (i.e., first prover message) according
     to the Schnorr protocol. For every $\lor$/$\land$ node, let the commitment be the union (as a set) of commitments below it.

    5. Compute the Schnorr challenge as the hash of the commitment of the root (plus other inputs -- probably the tree
     being proven and the message).

    6. top-down: compute the challenge for every real child of every real $\lor$ and $\land$, as follows. If $\lor$, then the
     challenge for the one real child of $\lor$ is equal to the XOR of the challenge of $\lor$ and the challenges for all the
     simulated children of $\lor$. If $\land$, then the challenge for every real child of $\land$ is equal to the the challenge of
     the $\land$. Note that simulated $\land$ and $\lor$ have only simulated descendants, so no need to recurse down from them.


Now, how to get a flat binary string containing $(e, z)$ pairs~(challenge and prover's response for a leafsub-protocol)
from the tree:



\subsection{Verifying A Transaction}


\subsection{Unified Transactions}

\subsection{Token Emission}
\input{tokens.tex}

\section{Voting}
\input{voting.tex}

\section{Proof-of-Work}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}
\addcontentsline{toc}{section}{References}

\end{document}
