\section{Voting}

Many parameters can be changed on-the-fly via miners voting, such as instructions costs, computational cost limit per block,
block size limit, storage fee factor, block version, and so on. Voting for the block version~(so for a soft-fork)
lasts for 32 epochs~(see epoch length below), and requires more than 90 percent of the miners to vote for the change.
For less critical changes~(such as block size limit), simple majority is enough. We will further refer to the changes
of the first kind as to foundational changes, we call the changes of the second kind as to everyday changes.
Per block, a miner can vote for two everyday changes and also one foundational change.

To vote "Yes"~("I'm agree on the change proposed"), and also to propose change in the first block of an epoch, a miner
is publishing identifier of the change directly in a block header. To vote "No" (or avoid voting at all, which is
the same), a miner is simply writing zero value instead of a corresponding byte (another option is to provide a vote
identifier which is not being considered within the epoch). To initialize a voting procedure, a miner is publishing
change identifier in a first block of an epoch.

System constants:
\begin{itemize}
\item{} Voting epoch length = 1024 blocks.
\item{} Voting epochs per foundational change = 32
\item{} Voting epochs before approved foundational change activation = 128
\end{itemize}

\subsection{Parameters table}
\label{sec:params-table}

The following table describes vote identifiers, default values (during launch), possible steps, and also minimum and maximum values.
If the step is not defined in the table, its value is defined as $\max(\lceil0.01 \times current\_value\rceil, 1)$.
If minimum value for a parameter is not defined, it equals to zero. If maximum value is not defined, it equals to
1,073,741,823.

To propose or vote for increasing a parameter, a miner is inluding a parameter identifier ($id$) into a blockheader.
If miner is for decreasing parameter, the miner is including ($-id$) into a block header.

\begin{tabular}{| l | l | l | l | l | l |}
\hline
Id & Description & Default & Step & Min & Max \\
\hline
\hline
1 & Storage fee factor  & 1250000 & 25000 & 0 & 5000000 \\
  &  (in nanoErgs per byte per storage period) & & & & \\
\hline
2 & Minimum monetary value of a box (in nanoErgs) & 360 & 10 & 0 & 10000 \\
\hline
3 & Maximum block size & 524288 & - & 16384 & - \\
\hline
4 & Maximum cumulative computational cost of a block & 1000000 & - & 16384 & - \\
\hline
\end{tabular}

Parameter values are to be written into extension section on first block of a voting epoch, that is, in the extension
of a block when its $height\,mod\,1024 = 0 \land height > 0$. Parameters for initial moment of time~$(height = 0)$ are simply
hardcoded. It is prohibited to start voting on $height = 0$.

\subsection{Proposing a change and voting for it}

To propose a change, in the first block of a voting epoch (of $1,024$ blocks, so in a block of
$height\,mod\,1024 = 0 \land height > 0$), a miner is posting vote for a change. There are three slots (three bytes)
in a block header for changes to propose, with two slots for everyday chanegs and third one to propose a softfork. Slot
not occuppied by a proposal is to be set to zero. Votes could come in any order. Examples of the bytes:
$(0, 1, 120)$, $(0, -3, 120)$. In the first case, a miner is proposing to increase storage fee factor ($id:1$), and
also proposes a soft-fork ($id:120$), In the second case, a miner is proposing to decrease block size ($id:-3$), and also
 is proposing a soft-fork ($id:120$).

To vote for a proposal~(proposed in the first block of an epoch) within the epoch, a miner is including vote identifier
into the block header. Identifiers not proposed in the first block of the epoch are ignored.

If majority of votes within an epoch are supporting an everyday change (so at least 513 blocks are containing an
identifier), a new value of the parameter should be written into the extension section of the first block of the next
epoch.

\subsection{Voting for a soft-fork}

A soft-fork is when a protocol version supported by the network is being increased. This version is written in a block
header. Semantics behind versioning is not defined ahead of time by the protocol and so up to clients and their
developers.

To start voting for a soft-fork, a miner needs to publish the identifier $120$ in the first block of the epoch, consider,
for example, that its height is $h_s$. Next epoch, a miner should post height when start fork was proposed ($122: h_s$)
in the extension section of the block, and number of votes collected in the previous epochs $v_s$ should be written
there as well as $(121, v_s)$.