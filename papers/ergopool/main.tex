\documentclass[11pt]{article}
%\documentclass[runningheads]{llncs}
\def\shownotes{1}
\def\notesinmargins{0}

%\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\powname}{Autolykos\xspace}
\newcommand{\poolname}{ErgoPool\xspace}
\newcommand{\mixname}{ErgoMix\xspace}


\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}

\newcommand{\primname}{Commitment of Work\xspace}
\newcommand{\prim}{CoW\xspace}


\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}


\title{\poolname: Breaking Non-Outsourceable Puzzles Using Smart Contracts (working title)}
\author{Ergo Developers}
%\institute{Ergo Platform}
\maketitle

\begin{abstract}
	Ergo is a proof-of-work (PoW) smart contract platform based on the UTXO model. Its underlying PoW, called \powname, is designed to be {\em non-outsourceable} or {\em pool-resistant}, which in simplet terms means that the system aims to prevent mining centralization by discouraging pool formation. 
	In this work, we show how create a centralized mining pool for Ergo and thereby break its pool resistance. Our ideas are generic enough to be applied to other non-outsourseable puzzles provided that the underlying smart contract language is expressive enough. 
	
\end{abstract}

\section{Introduction}
\snote{Below text copied from PoW intro paper}

Ergo\footnote{\url{https://ergoplatform.org}} is a smart contract platform whose contracts are written in a high-level language called \langname. It provides Ethereum-like functionality but is more closer to Bitcoin in the underlying design. For instance, it is based on short-lived immutable objects (called UTXOs in Bitcoin and {\em boxes} in Ergo) instead of long-lived mutable objects (called accounts in Ethereum) to store data and code. It also has some features different from both Bitcoin and Ethereum relating to scalability and long-term survivability. For instance, it has a {\em storage-rent} component, so that boxes must pay rent to continue staying on the blockchain. Secondly, it allows running a fully verifying node on low-power devices using the idea of partially stateless clients implementation~\cite{RMCI17}. Finally, it uses a PoW algorithm called \powname~\cite{autolykos} that discourages mining-pool formation, which we informally term {\em pool-resistance}. 

\section{Background}
\subsection{Outsourceable Puzzles}

Below describes how generic outsourceable puzzles work. 

\snote{Following is more or less copy-pasted from PoW intro paper. Needs rework}


In Bitcoin, a miner collects a number of unconfirmed transactions and concatenates them using a Merkle tree. All nodes of this tree except the leaves are 32 byte hashes computed from its children. The root of this tree, denoted $t$ here, is stored in another structure called the {\em block header}, which also includes the hash of the previous block's header $h$ and a random string $n$ called the nonce. We use the term $m$ to denote the concatenation of Merkle root and the hash of the previous block. 
That is, $m = t\|h$ and the header is of the form $m\|n$. 

The solution is also determined by another parameter $b < 2^{256}$, denoting the `difficulty'. Let $H$ be a collision resistant hash function taking as input an arbitrary sized array of bits and outputting an array of 256 bits. The output of $H$ can be considered a number between 0 and $2^{256}-1$. The header $m\|n$ is considered a valid solution if $H(m\|n) \leq b$. 

A miner repeatedly tries different values of $n$ (possibly changing $m$ as well by including new transactions in between tries) until a solution is found. Since the output of $Hash$ can be thought of as distributed uniformly in the output space, the probability of finding a solution in each try is $\tau = b/2^{256}$. All proof-of-work algorithms (including that of Ergo) follow this basic idea of restricting the output to be less than some $b$. It is worth noting that, for Bitcoin, as of this writing (July 2019), $b\approx 2^{181}$, and so $\tau \approx 2^{-75}$. %\approx 10^{-22.6} \approx 0.0000000000000000000000257$.

\textbf{Mining Pools:} Bitcoin allows mining pools, which roughly work as follows. The pool distributes work, based on a some $m$ that it decides. Each miner tries to find a solution for the given $m$ and any solution found is sent to the network. 
A miner actually tries to find a {\em share}, which is like a solution but with reduced difficulty (also decided by the pool). Some of the shares may also be real solutions, which become valid blocks. A miner gets paid by the number of shares submitted.
The key observation with pools is that miners do work for some other entity who then distributes the rewards back to the workers.
We define three levels of centralization in pools. 

\begin{enumerate}
	\item {\em Level 1 (Complete centralization):} The pool operator is defines both $m$ and the reward address. Thus, a pool operator has full control over which transactions are included (censorship) and also carries the risk of losing the rewards.
	\item {\em Level 2 (Partial centralization):} The pool operator does not defines $m$ but collects the rewards. This is resistant to censorship but still carries the risk of losing the rewards. This is what we will try achieve. 
	\item {\em Level 3 (No centralization):} There is no pool operator and rewards are automatically given to the participants based on the shares they submitted (P2Pool for Bitcoin and SmartPool for Ethereum).
\end{enumerate}
We also add another parameter, namely {\em mineability}, which captures the ability of miners with smaller investments to join and receive small but frequent rewards rather than large but infrequent ones, despite the yield of the latter being larger over a long time. If the system does not allow smaller miners to receive any rewards in a reasonable time, we say that the system has low mineability and is only suitable for larger miners (and will eventually lead to centralization). A system with high mineability allows miners to receive a steady income to cover running costs their mining equipment, thereby encouraging such miners to join and keep the mining power spread over a larger network.
The following table summarizes the concepts.\\

	\begin{tabular}{lllll}
		& Level & Censorship & Reward Risk & Mineability \\\hline
		& 1 (full centralization)    & Yes & Yes & High \\
		& 2 (partial centralization)    & No & Yes & High \\
		& 3 (no centralization)    & No & No & Low
	\end{tabular}

~\\

Note that P2Pool and SmartPool operate at Level 3 but maintain high minability because they only work in systems that also support Levels  1 and 2. In particular, these approaches don't work in systems that are designed to operate only in Level 3, such as the non-outsourceable puzzles of~\cite{} (see next Section). 

Ergo is also designed as a Level 3 platform. However, Ergo's scripting language, \langname enables us to create \poolname, a mining pool for Ergo that operates at Levels 1 and 2. In particular, we use the block solution (available as contextual information in \langname) to define a pooled mining contract.

\subsection{Non-Outsourceable Puzzles}

Discuss weak and strong variants; pool resistance; other works

We start with overviewing (non-)outsourceability definitions in existing literature. Different works, such as
Non-outsourceable Scratch-Off Puzzles~\cite{miller2015nonoutsourceable}, 2-Phase Proof-of-Work (2P-PoW)~\cite{twophase},
PieceWork~\cite{daian2017short}, Autolykos~\cite{autolykos}.


Non-outsourceability definitions could be simply split into two classes 



\snote{Following is copied from PoW intro paper}

A non-outsourceable puzzle is one with the following properties~\cite{miller2015nonoutsourceable}. If any party is able to generate a solution $d$ for some block header $m$ that sends rewards to a pool address, then the same party can then efficiently generate another solution $d'$ for an $m'$ that sends rewards to any other chosen address, and that too without revealing the identity. This results in a race condition where the party can steal the rewards if the solution to $m'$ gets accepted, thereby making it non-outsourceable. 

We note that non-outsourceability of~\cite{miller2015nonoutsourceable} is preserved if the ability to steal the rewards is present in the spending stage rather than in the mining stage. That is, any party that generates a valid solution for $m$ then has the ability to spend the reward transaction of $m$ in an untraceable manner. 
In this view, Ergo is a special instance of a non-outsourceable puzzle of~\cite{miller2015nonoutsourceable}, where the contention is not to generate a new message $m'$, that sends the reward to a different address (which is not possible in Ergo). Instead the goal is to steal the reward 720 blocks later, when it becomes spendable. 

\subsection{Overview of Execution Context in Ergo}

To give understanding of how a smart contract can bypass non-outsourceability, we first explain what kind of data the contract
can access.

In Proof-of-Work currencies a block is split usually into sections, with a compact section called {\em header} which is
enough to verify Proof-of-Work puzzle solution and also to check integrity of other sections (such as block transactions).

Execution context is what available to a contract during execution. Considering UTXO-based cryptocurrencies, such as
Bitcoin and Ergo, we can think about following components of the execution context. In the first place, smart contract
 may have access to the UTXO it is locking (e.g. monetary value of the UTXO). In the second place, smart contract may
 have access to the spending transaction with its inputs and outputs. In the third place, smart contract may have access
 to block header data. For example, in Ergo last ten block headers and also parts of the next block header which could
 be known to the miner before starting mining of the new block do belong to the execution context. Finally, execution
 context may contain the full block with all its transactions. Please note, as execution context must be fit into
 random-access memory of commodity hardware, accessing full blockchain is not the realistic case. Table \ref{???}
 summarizing possible execution context components.


\begin{tabular}{llllllll}
	& Level & UTXO & Transaction & Header      & Block & Example \\ \hline
	& 1     & No  & No          & No  		   & No    & Bitcoin \\
	& 2     & Yes & Yes         & No 		   & No    & -- \\
	& 3     & Yes & Yes         & Yes 		   & No    & Ergo    \\
	& 4     & Yes & Yes         & Yes 		   & Yes   & --    \\
\end{tabular}
	

\section{Overview of \powname}

Discuss how \powname fits above definition of non-outsourceable puzzles.

\section{\poolname}

\subsection{Security Aspects}

Broadcast attack and its variants. How to prevent it if smart contract language does not allow access to mining solution?

\subsection{Decentralized \poolname}

How to make it work like SmartPool or P2Pool

\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{main}
\appendix


\end{document}