

\section{Contractual Money}
    \label{sec:contractual}

 In our opinion, the overwhelming majority of use-cases for a public blockchain are about financial applications,
 even in case of a platform which claims to be a general-purpose decentralized world computer.
 For example, if an oracle is writing down
 non-financial data into a blockchain~(such as temperature), this data is usually to be used further in a financial
 contract. Another trivial observation we have made is that many applications are using digital tokens with mechanics
 different from a native one.

 The Ergo Platform is offering an application developer custom tokens~(which are first-class citizens) and a
 domain-specific language for box protecting
 condition in order to implement flexible and secure financial applications.
 Ergo applications are defined in terms of protecting scripts built into boxes also containing
 data possibly involved into execution. We coin the term {\em contractual money} for Ergs and secondary tokens which
 usage is bounded by a contract, so all the tokens on the platform in existence.

 Any box with its contents~(Ergs, tokens, data) is bounded by a contract.
 However, we can distinguish Ergs in existence as ones which could easily
 change their contracts from Ergs which are bounded by contracts in the sense that a box with contractual Ergs is
 demanding from a spending transaction to create boxes with some properties. We will refer to the former as to ordinary
 (or cleared, or free) Ergs, and to the latter as to the bounded Ergs. Similarly, we can define bounded tokens. Both
 free and bounded Ergs are contractual, and in some cases hybrids are possible, for example, for one public key it could
 be a bounding contract, and for another public key not.

 For example, if a box is protected just by a public key~(so providing a signature against a spending transaction is
 enough in order to destroy the box), a public key owner may create an arbitrary box replacing the one being protected
 by the public key, thus the Ergs within the box are free to change the contract. In contrast, imagine a box "B" which
 is protected by combination of a public key and also condition which demands a spending transaction to create an output
 box which guarding script hash is equal to "rBMUEMuPQUx3GzgFZSsHmLMBouLabNZ4HcERm4N" (in Base58 encoding), and Ergs
 value of the output should equal to the value of the original box. In this case, box value is bounded by the contract,
 thus Ergs in the box are bounded Ergs.

\subsection{Prelimiaries For Ergo Contracts}

  While in Bitcoin a transaction output is protected by a program in a stack-based language named Bitcoin Script,
  in Ergo a
 box is protected by a logic formula which combines predicates over a context and cryptographic statements provable
 via zero-knowledge protocols with AND, OR, and k-out-of-n connectives. The formula is represented as a typed direct
 acyclic graph, which serialized form is written in a box. To destroy a box, a spending transaction needs to provide
 arguments, including zero-knowledge proofs, which are enough to satisfy the formula.

 However, in most cases, a developer is unlikely to develop box contracts in terms of graphs. Instead, he would likely
 using a high-level language, and we provide one with the reference client called ErgoScript. Writing scripts in this
 language is easy, for
 example, for a one-out-of-two signature, protecting script would be ${pk_1 \&\& pk_2}$, which means "prove knowledge of
 a secret key corresponding to the public key $pk_1$ and knowledge of a secret key corresponding to $pk_2$". We have
 two separate documents which are helping to develop contracts with ErgoScript, the "ErgoScript Tutorial"~\cite{ergoTutorial}
 and the "Advanced ErgoScript Tutorial"~\cite{ergoAdvTutorial}. Thus below we are not going to dive into developing contracts with
 ErgoScript, rather, we are going to provide a couple of motivating examples in the following sections.

 More features of Ergo which are shaping contracting possibilities:

 \begin{itemize}
    \item{Data Inputs: }
 a box could be not only destroyed by a transaction, but be read-only, in the latter case we refer to the
 box as to {\em data input} box of the transaction. Thus a transaction is getting two box sets as its arguments, inputs and
 data inputs, and produces a box set named {\em outputs}. Data inputs are useful for oracle applications and interacting
 contracts.

    \item{Custom tokens: }
 a transaction can carry many tokens, if only estimated complexity for processing them is not exceeding a limit. A
 transaction is also able to issue a token, but only one, and with a unique~(and cryptographically strong against
 finding a collision) identifier, which is equal to identifier of a first~(spendable) input box of the transaction.
 The amount of the tokens issued could be any number within the [1, 9223372036854775807] range. For the tokens, the weak
 preservation rule is defined, which is demanding total amount for a token in transaction outputs should be no more
 than total amount for the token in transaction inputs~(thus some amount of token could be burnt). In contrast, for Ergs
 a preservation rule is strong, thus total Ergs amount for inputs should be equal to total Ergs amount for outputs.
 \end{itemize}

\subsection{Contract Examples}
\label{sec:examples}

 In this section we provide some examples which are clearly show superiority of Ergo contracts in comparison with
 Bitcoin. The examples are including a bet on oracle-provided data, non-interactive mixing, atomic swap,
 complementary currency, and initial coin offering implemented on top of the Ergo blockchain.

 \subsubsection{An Oracle Example}
 \label{sec:platform}

 Equipped with custom tokens and data inputs, we can develop a simple oracle example, also showing on the way some
 design patterns that we have discovered while playing with Ergo contracts. Assume that Alice and Bob are going to bet
 on weather tomorrow. For that, they are putting money into a box, which is spendable by
 Alice if the temperature is more than 15 degrees, and is spendable by Bob otherwise. To deliver the temperature into the
 blockchain a trusted oracle is needed.

 In opposite to Ethereum with its long-lived accounts, where trusted oracle identifier is usually known in advance,
 delivering data with one-time boxes is more tricky. For starters, a box which is protected by an oracle's key could
 not be trusted, as anyone can create such a box. It is possible to include a signed data into a box, and check the
 signature in the contract using the data, we have such an example, but this example is quite involved. With custom
 tokens, however, a solution is pretty simple.

 In the first place, a token identifying the oracle should be issued. In the simplest case, the amount for the token could
 be equal to one. We call such a token {\em a singleton token}. Then the oracle is creating a box containing the token
 and also data, namely, temperature in the register number four~($R4$), and time~(in seconds since the beginning of
 the UNIX epoch) in the register number five($R5$).
 In order to update temperature, an oracle is destroying the box and creating a new one with updated temperature.

 Assume that Alice and Bob know oracle's token identifier in advance. With this knowledge, they
 can jointly create a box which requires first data input (which is read-only) to contain the oracle's token. The
 contract is extracting temperature and time from the data input
 and decides who is getting the payout. The code is as simple as following:

 \begin{algorithm}[H]
    \caption{Oracle Contract Example}
    \label{alg:oracle}
    \begin{algorithmic}[1]
        \State val dataInput = CONTEXT.dataInputs(0)
        \State val inReg = dataInput.R4[Long].get
        \State val inTime = dataInput.R5[Long].get
        \State val inToken = dataInput.tokens(0).\_1 == tokenId
        \State val okContractLogic = (inTime $>$ 1556089223) \&\&
        \State\hspace{\algorithmicindent}\hspace{\algorithmicindent} ((inReg $>$ 15L \&\& pkA) $||$ (inReg $\le$ 15L \&\& pkB))
        \State inToken \&\& okContractLogic
    \end{algorithmic}
 \end{algorithm}

 This contract shows how a singleton token could be used for authentification. As a possible alternative, an oracle
 can put signed time and temperature into a box along with a signature for the data published. However, this requires
 signature checking in a contract which is using an oracle box, which is more complex and expensive, in comparison with
 the singleton token approach. Also the contract shows how read-only data inputs could be useful for contracts which do
 need access to data in some box in the state. Without data inputs, an oracle needs to issue a spendable box for every
 pair of Alice and Bob. With data inputs support, the oracle is issuing only a single box per arbitrary number of users.

\subsubsection{A Mixing Example}
 \label{sec:platform}

 Privacy is important for a digital currency, but implementing it in a protocol could be costly or require a trusted
 setup. Thus we are looking for ways to do coin mixing via cheap enough applications. As a first step towards that, we
 offer an application for non-interactive coin mixing, which is working in the following case:
 \begin{enumerate}
    \item{} Alice creates a box which demands any Bob's box to satisfy certain conditions in order to be mixed with
    the coin of Alice. After that, Alice only listens to the blockchain, no any interaction with Bob is needed.
    \item{} Bob is creating a box and then a spending transaction which has boxes of Alice and Bob as inputs,
     and creates two outputs with the same script, but both Alice and Bob may spend only one box out of the two.
     An external observer can not decide which output is spent by whom, as output boxes are indistinguishable.
 \end{enumerate}

 For simplicity, we are not considering fees in the example. The idea of mixing is similar to non-interactive
 Diffie-Hellman key exchange. First, Alice creates a secret value $x$~(a huge number) and publishing a corresponding
 public value $gX = g^x$. She demands from Bob to generate a secret number $y$, and to include into each output two
 values $c1$, $c2$, where one value is equal to $g^y$ and another is equal to $g^{x \cdot y}$. We assume that a Bob is using
 a random coin to choose meanings for $\{c_1, c_2\}$. With no access to the secret information, an external
 observer can not guess whether, for example, $c_1$ is about $g^y$ or $g^{x \cdot y}$, with probability above
 $\frac{1}{2}$ (as a cryptographic primitive we are using has a certain property, namely, the hardness of
 Diffie-Hellman decisional problem). To destroy an output box, a proof should be given that for $c_2$ whether $y$ is known,
  such that $c_2 = g^y$, or $c_2 = g^{x \cdot y}$ has the same exponent $x$ against $c1 = g^y$ as $g^x$ against $g$.
 The contract of the Alice's box is checking that $c1$ and $c2$ are well-formed. The code snippets for the Alice's coin and
 a mixing transaction output are provided in Algorithm \ref{alg:alice} and Algorithm \ref{alg:mixing-out}, respectively.

 \begin{algorithm}[H]
    \caption{Alice's Input Script}
    \label{alg:alice}
    \begin{algorithmic}[1]
        \State val c1 = OUTPUTS(0).R4[GroupElement].get
        \State val c2 = OUTPUTS(0).R5[GroupElement].get
        \State
        \State OUTPUTS.size == 2 \&\&
        \State OUTPUTS(0).value == SELF.value \&\&
        \State OUTPUTS(1).value == SELF.value \&\&
        \State blake2b256(OUTPUTS(0).propositionBytes) == fullMixScriptHash \&\&
        \State blake2b256(OUTPUTS(1).propositionBytes) == fullMixScriptHash \&\&
        \State OUTPUTS(1).R4[GroupElement].get == c2 \&\&
        \State OUTPUTS(1).R5[GroupElement].get == c1 \&\& \{
        \State\hspace{\algorithmicindent}  proveDHTuple(g, gX, c1, c2) $||$
        \State\hspace{\algorithmicindent}  proveDHTuple(g, gX, c2, c1)
        \State \}
    \end{algorithmic}
 \end{algorithm}

 \begin{algorithm}[H]
    \caption{Mixing Transaction Output Script}
    \label{alg:mixing-out}
    \begin{algorithmic}[1]
        \State val c1 = SELF.R4[GroupElement].get
        \State val c2 = SELF.R5[GroupElement].get
        \State proveDlog(c2) $||$            // either c2 is $g^y$
        \State proveDHTuple(g, c1, gX, c2) // or c2 is $u^y = g^{x \cdot y}$
    \end{algorithmic}
 \end{algorithm}

 We refer to the \cite{ergoAdvTutorial} for a proof of outputs indistinguishability and details on why
 Alice and Bob can spend only their respective coins.


\subsubsection{More Examples}

 In this section we are briefly shedding a light on few more examples along with links to documents providing
 details and code.

\paragraph{Atomic Swap}

Cross-chain atomic swap Ergo and another blockchain~(supporting a payment to SHA-256 or Blake2b-256 hash preimage
and a time-lock) could be done in the same way as proposed for Bitcoin, see initial protocol for Bitcoin in
\cite{Nol13}, its Ergo alternative is provided in~\cite{ergoTutorial}. As Ergo has custom tokens,
atomic exchange on a single block chain (Erg-to-token or token-to-token) is also possible, a solution for that can be
found~\cite{ergoTutorial}.

\paragraph{Crowdfunding}

 We consider a simplest crowdfunding scenario. In the example, a crowdfunding project with a known public key
 is considered successful if it
 can collect unspent outputs with total value not less than a certain amount before
 a certain height. A project backer creates an output box protected by the following statement: the box can be spent
 if a spending transaction is having its first output box protected by the project's key, and the output should have
 no less than the target amount.
 Then the project can collect biggest backer output boxes with total value not less
 than the amount with a single transaction~(it is possible to collect up to ~22,000 outputs in Bitcoin, which is
 enough even for a big crowdfunding campaign). For remaining small outputs over the amount, it is possible to
 construct follow-up transactions. The code can be found in~\cite{ergoTutorial}.

\paragraph{The Local Exchange Trading System}

 Here we briefly overview a local exchange trading system implementation. In such a system, a member of a community may
 issue community currency via personal debt. For example, if Alice with zero balance is buying something for $5$
 community tokens from Bob, which balance is about zero as well, her balance after the trade would be $-5$ tokens, and
 Bob's balance would be $5$ tokens. Then Bob can buy something for his $5$ tokens, for example, from Carol.
 Usually, in such systems, there is a limit for negative balance (to avoid free-riding).

 As digital community could be vulnerable to sybil attacks~(which allow to do free-riding again), thus some mechanism
 is needed in order to prevent the creation of sybils creating debts. We consider two solutions, namely, a committee of
 trusted managers approving new members of the community, or security deposits made in Ergs. For simplicity, we
 consider the approach with the committee here.

 This example is about two interacting contracts then. A management contract is about maintaining a
 community members list, and a new member could be added if management condition satisfied  (for example, a threshold
 signature is provided). A new member is associated with a box which contains a token identifying the member. The user
 box is protected by a special exchange script requiring to do a fair exchange only for a spending transaction.
 We skip the corresponding code, but it could be found in a separate article~\cite{icoTutorial}.

 What this contract shows, in comparison with previous example, is that instead of storing a members list, only a short
 digest of an authenticated AVL+ tree is to be included into a box. That allows to reduce storage requirements for the
 state. A transaction which is doing lookup or modification of the member list should provide a proof for AVL+ tree
 lookup or modification operations. Thus saving space in the state storage leads to bigger transactions, but the latter
 problem for scalability is easier to solve.


\paragraph{Initial Coin Offering}

 An initial coin offering (ICO) example shows very clearly how to develop a multi-stage contract in Ergo. Like most of
 ICOs, our example is about three stages. In the first stage the project is raising money in Ergs. In the second stage,
 the project is issuing a new token, with amount of tokens to be equal to an amount of nanoErgs raised in the stage. In
 the third stage, investors can withdraw issued tokens.

 Note that the first stage could be about many transactions on
 the blockchain, as well as the third stage, while for the second stage a single transaction is enough. As in the
 previous example, an ICO contract box will contain a list of investors, now stored along with investments.


\paragraph{Even More Examples}

 We have more examples of Ergo applications, such as time-controlled emission, cold wallet, rock-paper-scissors game,
 and so on. The examples could be found in \cite{ergoTutorial, ergoAdvTutorial}.